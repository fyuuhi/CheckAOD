#include <EventLoop/Job.h>
#include <EventLoop/StatusCode.h>
#include <EventLoop/Worker.h>
#include <MyNewPackage/MyAnalysisAlg.h>
#include <xAODEventInfo/EventInfo.h>
#include "AsgTools/MessageCheck.h"
#include "xAODRootAccess/Init.h"
#include "xAODRootAccess/TEvent.h"
#include "xAODMuon/MuonContainer.h"
#include "xAODTrigMuon/L2StandAloneMuonContainer.h"
#include <TSystem.h>
#include "GoodRunsLists/GoodRunsListSelectionTool.h"
#include <TH1.h>
#include <TTree.h>
// this is needed to distribute the algorithm to the workers

//(http://epp.phys.kyushu-u.ac.jp/~oda/pukiwiki/index.php?xAOD%B2%F2%C0%CF2014#o027ed25) --->>> about invariant mass


ClassImp(MyAnalysisAlg)


MyAnalysisAlg :: MyAnalysisAlg ()
{
  // Here you put any code for the base initialization of variables,
  // e.g. initialize all pointers to 0.  Note that you should only put
  // the most basic initialization here, since this method will be
  // called on both the submission and the worker node.  Most of your
  // initialization code will go into histInitialize() and
  // initialize().
}



EL::StatusCode MyAnalysisAlg :: setupJob (EL::Job& job)
{
  job.useXAOD();
  ANA_CHECK( xAOD::Init() );
  // Here you put code that sets up the job on the submission object
  // so that it is ready to work with your algorithm, e.g. you can
  // request the D3PDReader service or add output files.  Any code you
  // put here could instead also go into the submission script.  The
  // sole advantage of putting it here is that it gets automatically
  // activated/deactivated when you add/remove the algorithm from your
  // job, which may or may not be of value to you.
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: histInitialize ()
{
  // Here you do everything that needs to be done at the very
  // beginning on each worker node, e.g. create histograms and output
  // trees.  This method gets called before any input files are
  // connected.

  ///TTree
  m_tree = new TTree("tree", "tree");
  m_muonPt = new std::vector< Double_t >();
  m_L2SAPt = new std::vector< Double_t >;
  m_muon_eta = new std::vector< Double_t >;
  m_muon_phi = new std::vector< Double_t >;
  m_muon_e = new std::vector< Double_t >;
  //m_muon_m = new std::vector< Double_t >;
  m_L2SA_eta = new std::vector< Double_t >;
  m_L2SA_phi = new std::vector< Double_t >;
  m_L2SA_e = new std::vector< Double_t >;
  //m_L2SA_m = new std::vector< Double_t >;
  m_dimuon_mass = new std::vector< Double_t >;
  m_charge = new std::vector< Double_t >;
  m_charge_SA = new std::vector< Double_t >;
  m_tree -> Branch("muonPt",&m_muonPt);
  m_tree -> Branch("L2SAPt",&m_L2SAPt);
  m_tree -> Branch("muon_eta",&m_muon_eta);
  m_tree -> Branch("muon_phi",&m_muon_phi);
  m_tree -> Branch("muon_e",&m_muon_e);
  //m_tree -> Branch("muon_m",&m_muon_m);
  m_tree -> Branch("L2SA_eta",&m_L2SA_eta); 
  m_tree -> Branch("L2SA_phi",&m_L2SA_phi);
  m_tree -> Branch("L2SA_e",&m_L2SA_e);
  //m_tree -> Branch("L2SA_m",&m_L2SA_m);
  m_tree -> Branch("dimuon_mass",&m_dimuon_mass);
  m_tree -> Branch("charge",&m_charge);
  // m_tree -> Branch("charge_SA",&m_charge_SA);

  wk() -> addOutput(m_tree);
  //histogram
  m_h1muonPt = new TH1D("h1_muonPt","h1_muonPt;p_{T} MeV;events", 20, 0, 100e3);
  wk() -> addOutput( m_h1muonPt );
  
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: fileExecute ()
{
  // Here you do everything that needs to be done exactly once for every
  // single file, e.g. collect a list of all lumi-blocks processed
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: changeInput (bool firstFile)
{
  // Here you do everything you need to do when we change input files,
  // e.g. resetting branch addresses on trees.  If you are using
  // D3PDReader or a similar service this method is not needed.
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: initialize ()
{
  xAOD::TEvent* event = wk()->xaodEvent();
  Info("initialize()", "Number of events = %lli", event->getEntries() );
  m_grl = new GoodRunsListSelectionTool("GoodRunsListSelectionTool");
  const char* GRLFilePath = "$ROOTCOREBIN/data/MyNewPackage/data16_13TeV.periodAllYear_DETSTATUS-V89-PRO21-01_DQDefects-00-02-04_PHYS_StandardGRL_All_Good.xml"; 
  const char* fullGRLFilePath = gSystem->ExpandPathName (GRLFilePath);
  std::vector<std::string> vecStringGRL;
  vecStringGRL.push_back(fullGRLFilePath);
  ANA_CHECK(m_grl->setProperty( "GoodRunsListVec", vecStringGRL));
  ANA_CHECK(m_grl->setProperty("PassThrough", false));
  ANA_CHECK(m_grl->initialize());

  // Here you do everything that you need to do after the first input
  // file has been connected and before the first event is processed,
  // e.g. create additional histograms based on which variables are
  // available in the input files.  You can also create all of your
  // histograms and trees in here, but be aware that this method
  // doesn't get called if no events are processed.  So any objects
  // you create here won't be available in the output if you have no
  // input events.
  return EL::StatusCode::SUCCESS;
}


EL::StatusCode MyAnalysisAlg :: execute ()
{
  m_muonPt -> clear();
  m_L2SAPt -> clear();
  m_muon_eta -> clear(); 
  m_muon_phi -> clear();
  m_muon_e -> clear();
  //m_muon_m -> clear();
  m_L2SA_eta -> clear(); 
  m_L2SA_phi -> clear();
  m_L2SA_e -> clear();
  //m_L2SA_m -> clear();
  m_charge -> clear(); 
  //m_charge_SA -> clear();
  m_dimuon_mass -> clear();

  xAOD::TEvent* event = wk()->xaodEvent();
  const xAOD::EventInfo* eventInfo = 0;
  ANA_CHECK(event->retrieve(eventInfo, "EventInfo"));
  int runNumber = eventInfo->runNumber();
  int eventNumber = eventInfo->eventNumber();
  Info("execute()", "Run = %i : Event = %i", runNumber, eventNumber);
  
  
  const xAOD::MuonContainer* muons = 0; //// Container for offline muon
  ANA_CHECK( event -> retrieve( muons, "Muons") );
  xAOD::MuonContainer::const_iterator muon_end = muons -> end();
  for( xAOD::MuonContainer::const_iterator muon = muons -> begin() ; muon != muon_end; muon++ ) //// iterate over container
    Info( "execute()", "Offline Muon Pt = %4.2f MeV", (*muon) -> pt() );
  

  const xAOD::L2StandAloneMuonContainer* l2saMuons = 0;
  ANA_CHECK( event -> retrieve( l2saMuons, "HLT_xAOD__L2StandAloneMuonContainer_MuonL2SAInfo" ) );
  for( auto l2saMuon : *l2saMuons ){ //// brief description
    if ( l2saMuon -> algoId() != 1 ) continue; //// choose only muon algorithm id
    Info( "execute()", "L2SA Muon Pt = %4.2f GeV", l2saMuon -> pt() ); //// be careful of GeV( not MeV as usual ) and sign of pt means charge
  }


  //// Retrieve eventInfo above
  bool isMC = false;
  if ( eventInfo -> eventType( xAOD::EventInfo::IS_SIMULATION ) )
    isMC = true;
  if( !isMC ){
    if( !m_grl -> passRunLB( *eventInfo ) ){ Info( "execute()", "GRL not pass RunLB"); return EL::StatusCode::SUCCESS;
    } }
  
// Here you do everything that needs to be done on every single
  // events, e.g. read input variables, apply cuts, and fill
  // histograms and trees.  This is where most of your actual analysis
  // code will go.
  //const xAOD::MuonContainer* muons = 0;
  //ANA_CHECK( event -> retrieve( muons, "Muons") ); 

  const xAOD::Muon* highPtPosMuon = 0; // add (09/20) 
  const xAOD::Muon* highPtNegMuon = 0; // add (09/20)  

  for( auto muon : *muons ) {
    // const xAOD::Muon* highPtPosMuon = 0; // add (09/20)
    // const xAOD::Muon* highPtNegMuon = 0; // add (09/20)

    Info( "execute()", "Offline Muon Pt = %4.2f MeV", muon -> pt() ); //// Fill and push_back variables
    m_h1muonPt -> Fill( muon -> pt() );
    m_muonPt -> push_back( muon -> pt() );
    m_muon_eta -> push_back( muon -> eta() );
    m_muon_phi -> push_back( muon -> phi() );
    m_muon_e -> push_back( muon -> e() );
    m_charge -> push_back( muon -> charge() );
    //m_muon_m -> push_back( muon -> m() );

    //calculate highPtPosMuon & highPtNegMuon 
    if( muon -> charge() > 0.){//Positive muons
      if( !highPtPosMuon || (highPtPosMuon -> pt() < muon -> pt())) highPtPosMuon = muon;
    } else {//Negative muons
      if( !highPtNegMuon || (highPtNegMuon -> pt() < muon -> pt())) highPtNegMuon = muon;
    }
  }


  //calculate invariant mass of di-muon
  if( highPtPosMuon && highPtNegMuon ){
    // Get TLorentzVector of muons
    TLorentzVector p4_total = highPtPosMuon -> p4() + highPtNegMuon -> p4();
    //Get mass 
    double m = p4_total.M();
   
    m_dimuon_mass -> push_back(m/1.0); 
  }


  //const xAOD::L2StandAloneMuonContainer* l2saMuons = 0;
  //  ANA_CHECK( event -> retrieve( l2saMuons, "HLT_xAOD__L2StandAloneMuonContainer_MuonL2SAInfo") );


 for( auto l2saMuon : *l2saMuons ){
   if ( l2saMuon -> algoId() != 1 ) continue; //// choose only muon algorithm id 
   Info( "execute()", "L2SA Muon Pt = %4.2f GeV", l2saMuon -> pt() );
   //// Fill and push_back variables
   m_L2SAPt -> push_back( l2saMuon -> pt() );
   m_L2SA_eta -> push_back( l2saMuon -> eta() );
   m_L2SA_phi -> push_back( l2saMuon -> phi() );
   m_L2SA_e -> push_back( l2saMuon -> e() );
   //m_charge_SA -> push_back( l2saMuon -> charge() );
   //m_L2SA_m -> push_back( l2saMuon -> m() );

 }



 ////Fill tree
 m_tree -> Fill();

  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: postExecute ()
{
  // Here you do everything that needs to be done after the main event
  // processing.  This is typically very rare, particularly in user
  // code.  It is mainly used in implementing the NTupleSvc.
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: finalize ()
{
  delete m_muonPt; m_muonPt = 0;
  delete m_L2SAPt; m_L2SAPt = 0;
  delete m_muon_eta; m_muon_eta = 0; 
  delete m_muon_phi; m_muon_phi = 0;
  delete m_muon_e; m_muon_e = 0;  
  //delete m_muon_m; m_muon_m = 0;  
  delete m_L2SA_eta; m_L2SA_eta = 0; 
  delete m_L2SA_phi; m_L2SA_phi = 0;
  delete m_L2SA_e; m_L2SA_e = 0;           
  //delete m_L2SA_m; m_L2SA_m= 0;                               
  delete m_charge; m_charge = 0;
  delete m_charge_SA; m_charge_SA = 0;
  delete m_dimuon_mass; m_dimuon_mass = 0;
  

  // This method is the mirror image of initialize(), meaning it gets
  // called after the last event has been processed on the worker node
  // and allows you to finish up any objects you created in
  // initialize() before they are written to disk.  This is actually
  // fairly rare, since this happens separately for each worker node.
  // Most of the time you want to do your post-processing on the
  // submission node after all your histogram outputs have been
  // merged.  This is different from histFinalize() in that it only
  // gets called on worker nodes that processed input events.
  return EL::StatusCode::SUCCESS;
}



EL::StatusCode MyAnalysisAlg :: histFinalize ()
{
  // This method is the mirror image of histInitialize(), meaning it
  // gets called after the last event has been processed on the worker
  // node and allows you to finish up any objects you created in
  // histInitialize() before they are written to disk.  This is
  // actually fairly rare, since this happens separately for each
  // worker node.  Most of the time you want to do your
  // post-processing on the submission node after all your histogram
  // outputs have been merged.  This is different from finalize() in
  // that it gets called on all worker nodes regardless of whether
  // they processed input events.
  return EL::StatusCode::SUCCESS;
}
